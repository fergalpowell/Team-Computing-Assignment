#pragma config(Sensor, S3,     lightSensor,    sensorLightActive)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void reverseToCentre();
void moveToCentre();
void moveToEdge();
void changeDirection();
void updateObstacleMap(int currentColumn, int currentRow, int direction);
int checkCellColour(int threshold);
void navigateGrid();
	// declare our grid
int grid[5][5];
int currentColumn = 0;
int currentRow = 2;
int direction = 3;
	// 1 is north
	// 2 is south
	// 3 is east
	// 4 is west
int thresholdValue;
//to help with our random turns, left = 4, right = 6;
int lastTurn = 4;

task main()
{
	int lightValue;
	int darkValue;
	int sumValue;

	nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;

	darkValue=28;
	lightValue=65;
	sumValue = lightValue + darkValue;
	thresholdValue = sumValue/2;


	// 0 is white cell, 1 is black cell, 99 is start

	// initialise our grid
	for (int i = 0; i < 4; i++)
	{
		for (int j = 0; i < 4; i ++)
		{
			grid[i][j] = 0;
		}
	}
	grid[0][2] = 99;


	while(1==1)
	{
		navigateGrid();
	}
}

int checkCellColour(int threshold)
{
	if (SensorValue(lightSensor) < threshold)
	{
		// We are in a black Cell
		nxtDisplayCenteredTextLine(4, "We are in a black Cell");
		wait1Msec(1000);
		return 1;
	}
	else
	{
		// We are in a white Cell
		nxtDisplayCenteredTextLine(4, "We are in a white Cell");
		wait1Msec(1000);
		return 0;
	}
}

void moveToEdge()
{
	motor[motorB]=20;
	motor[motorC]=20;
	wait1Msec(1000);
	motor[motorB]=0;
	motor[motorC]=0;
}

void moveToCentre()
{
	motor[motorB]=20;
	motor[motorC]=20;
	wait1Msec(1000);
	motor[motorB]=0;
	motor[motorC]=0;

	if (direction == 1)
	{
		currentRow = currentRow - 1;
	}
	else if (direction == 2)
	{
		currentRow = currentRow + 1;
	}
	else if (direction == 3)
	{
		currentColumn = currentColumn+1;
	}
	else
	{
		currentColumn = currentColumn-1;
	}
	nxtDisplayClearTextLine(4);
	nxtDisplayCenteredTextLine(4, "Col: %d, Row: %d",currentColumn, currentRow);
	wait1Msec(3000);
}

void reverseToCentre()
{
	motor[motorB]=-20;
	motor[motorC]=-20;
	wait1Msec(1000);
	motor[motorB]=0;
	motor[motorC]=0;
}

void changeDirection()
{
	//Need to reverse back to centre of the cell and change direction
	reverseToCentre();
	// One approach is to always try and turn left. Will this cause any problems?
	// What about random left/right changes of direction, how will you do this?
	if (lastTurn == 4)
	{
		//turn right
		// Change facing direction
		// change lastTurn to be right
	}
	else
	{
		//turn left
		// Change facing direction
		// change lastTurn to be left
	}
}

void updateObstacleMap(int currentColumn, int currentRow, int direction)
{
	if (direction == 1)
		{
			//Facing north, so row above, same column is black
			grid[currentColumn][currentRow+1] = 1;

		}
	else if (direction == 2)
		{
			//Facing south, so row below, same column is black
			grid[currentColumn][currentRow-1] = 1;
		}
	else if (direction == 3)
		{
			//Facing east, so same row, next column is black
			grid[currentColumn+1][currentRow] = 1;
		}
	else
		{
			//Facing west, so same row, previous column is black
			grid[currentColumn-1][currentRow] = 1;
		}
}

void navigateGrid()
{
		int cellColour; //1 for black, 0 for white
		moveToEdge();
		cellColour = checkCellColour(thresholdValue);

		if (cellColour == 1)
		{
			// We are in a black Cell
			updateObstacleMap(currentColumn, currentRow, direction);
			// Need to avoid obstacle
			reverseToCentre();
			changeDirection();

		}
		else
		{
			// We are in a white Cell
			moveToCentre();

		}
	}
