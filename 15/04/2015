#pragma config(Sensor, S1,     sonarSensor,    sensorSONAR)
#pragma config(Sensor, S2,     lightSensor,    sensorLightActive)
#pragma config(Sensor, S3,     touchSensor,    sensorTouch)
#pragma config(Sensor, S4,     soundSensor,    sensorSoundDB)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Function prototype
void BlackCell();
void Forward();
void Reverse();
void TurnLeft();
void TurnRight();
void Stop();

int grid[9][7];
int currentRow = 0;
int currentColumn = 5;
int direction = 3;
	// 1 = north
	// 2 = south
	// 3 = east
	// 4 = west

int location = 4;

task main()
{
	BlackCell();
}

void BlackCell()
{
	//0 menas  right, 1 means left
	int lastTurn = 1;

	while(true)
	{
		while(SensorValue(lightSensor) > 40)
		{
			nxtDisplayCenteredTextLine(4, "We are in a white Cell");
			wait1Msec(1000);
			
			grid[currentRow][currentColumn] = 0;//1 means white cell
			
			nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
			nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;

			nMotorEncoder[motorB] = 0;
			nMotorEncoder[motorC] = 0;

			Forward();
		}//end inner while

		if(SensorValue(lightSensor) < 40 )
		{
			nxtDisplayCenteredTextLine(4, "We are in a black Cell");
			wait1Msec(1000);
			
			grid[currentRow][currentColumn] = 1;//1 means black cell
	
			Reverse();
			
			if(lastTurn == 1)
			{
				TurnLeft();
				lastTurn = rand() % 2;
			}//end inner if
			else
			{
				TurnRight();
				lastTurn = rand() % 2;
			}//end else
		}//end outer if
		else
		{
			Forward();
		}
	}//end outer while
		
}//end black_lines()

void Forward()
{
	//if ( !(currentRow > 9 || currentRow < 0 || currentColumn < 0 || currentColumn > 7) )
	//{
		nMotorPIDSpeedCtrl[motorB]=mtrSpeedReg;
		nMotorPIDSpeedCtrl[motorC]=mtrSpeedReg;
	
		nMotorEncoder[motorB] = 0;
		nMotorEncoder[motorC] = 0;
		
		nMotorEncoderTarget[motorB]=270;
		nMotorEncoderTarget[motorC]=270;
	
		motor[motorB]=30;
		motor[motorC]=30;
		
		//Updating the current cell
		switch(direction)
		{
			case 1:
			{
				currentColumn++;
			}
			
			case 2:
			{
				currentColumn--;
			}
			
			case 3:
			{
				currentRow++;
			}
			
			case 4:
			{
				currentRow--;
			}
		}
		
		location = (7 * currentRow) + currentColumn;
	//}

}

void Reverse()
{
	motor[motorB]=-30;
	motor[motorC]=-30;
	wait1Msec(1000);
}

void TurnLeft()
{
	nMotorPIDSpeedCtrl[motorB]=mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorC]=mtrSpeedReg;

	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;
	
	nMotorEncoderTarget[motorB] = 189;
	nMotorEncoderTarget[motorC] = -189;

	motor[motorB]=30;
	motor[motorC]=-30;

	while( nMotorRunState[motorC]!=runStateIdle)
	{}

	motor[motorB]=0;
	motor[motorC]=0;
	
	switch(direction)
	{
		case 1:
		{
			direction = 4;
		}
		
		case 2:
		{
			direction = 3;
		}
		
		case 3:
		{
			direction = 1;
		}
		
		case 4:
		{
			direction = 2;
		}
	}
}


void TurnRight()
{
	nMotorPIDSpeedCtrl[motorB]=mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorC]=mtrSpeedReg;

	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;
			
	nMotorEncoderTarget[motorB]=187;
	nMotorEncoderTarget[motorC]=-187;

	motor[motorB]=-30;
	motor[motorC]=30;

	while( nMotorRunState[motorC]!=runStateIdle)
	{}

	motor[motorB]=0;
	motor[motorC]=0;
	
	switch(direction)
	{
		case 1:
		{
			direction = 3;
		}
		
		case 2:
		{
			direction = 4;
		}
		
		case 3:
		{
			direction = 2;
		}
		
		case 4:
		{
			direction = 1;
		}
	}
}

void Stop()
{
	nMotorPIDSpeedCtrl[motorB]=mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorC]=mtrSpeedReg;

	motor[motorB]=0;
	motor[motorC]=0;
}
